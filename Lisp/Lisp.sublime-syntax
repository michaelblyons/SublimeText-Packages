%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
#
# `Common Lisp` Language Reference:
# https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/index.html
#
name: Lisp
file_extensions:
  - lisp
  - cl
  - clisp
  - l
  - mud
  - el
  - scm
  - ss
  - lsp
  - fasl # Scheme dialect of Lisp
variables:
  identifier_forbidden: '[\s()''"/,:;]' # Also `|` but they can be internal delimiters
  identifier_must_have: (?:[^\s()'"/,:;|\d.]|\\.) # May not be only digits or periods
  identifier_char: (?:\d|\.|{{identifier_must_have}})
  identifier: '{{identifier_char}}*{{identifier_must_have}}{{identifier_char}}*'
  end_identifier: (?={{identifier_forbidden}}|$)
  standard_char: '[\w!"#$%&''()*+,\-./:;<=>?@\[\\\]^{|}~]'
  declarations: |-
    \b(?xi:
      declaim|declare|define-condition|define-compiler-macro|
        define-declaration|define-method-combination|define-setf-method|
        defclass|defgeneric|defmacro|defmethod|define-modify-macro|defpackage|
        defsetf|defstruct|deftype|defun|defvar|defconstant|defparameter|
      flet|
      generic-flet|generic-function|generic-labels|
      labels|let\*?|locally|
      macrolet|multiple-value-bind|
      proclaim|prog\*?|
      with-accessors|with-added-methods|with-condition-restarts|
        with-input-from-string|with-open-file|with-open-stream|
        with-standard-io-syntax|
        with-output-to-string
    ){{end_identifier}}
scope: source.lisp
contexts:
  main:
    - include: comments
    - include: parens

  expressions:
    - include: comments
    - include: numbers
    - include: constants
    - include: dispatching-macros
    - include: strings
    - include: variables
    - include: control
    - include: types
    - match: \B\.{{end_identifier}}
      scope: keyword.control.lisp

  variables:
    - match: |-
        (\*)(?xi:
          trace-output|terminal-io|suppress-series-warnings|standard-output|
          standard-input|readtable|read-suppress|read-eval|
          read-default-float-format|read-base|random-state|query-io|
          print-right-margin|print-readably|print-radix|print-pretty|
          print-pprint-dispatch|print-miser-width|print-lines|print-level|
          print-length|print-gensym|print-escape|print-circle|print-case|
          print-base|print-array|package|modules|macroexpand-hook|load-verbose|
          load-truename|load-print|load-pathname|gensym-counter|features|
          evalhook|error-output|default-pathname-defaults|debugger-hook|
          debug-io|compile-verbose|compile-print|compile-file-truename|
          compile-file-pathname|break-on-warnings|break-on-signals|applyhook
        )(\*)
      scope: variable.language.lisp
      captures:
        1: punctuation.definition.variable.begin.lisp
        2: punctuation.definition.variable.end.lisp
    - match: (\*)(?:\S*)(\*)
      scope: variable.other.global.lisp
      captures:
        1: punctuation.definition.variable.begin.lisp
        2: punctuation.definition.variable.end.lisp

  control:
    # Conditional
    - match: \b(?i:if|cond){{end_identifier}}
      scope: keyword.control.conditional.if.lisp
    - match: \b(?i:else){{end_identifier}}
      scope: keyword.control.conditional.else.lisp
    - match: \b(?i:case){{end_identifier}}
      scope: keyword.control.conditional.case.lisp
    ## May be wrong
    - match: \b(?i:then|unless){{end_identifier}}
      scope: keyword.control.conditional.lisp
    # Flow
    - match: \b(?i:return){{end_identifier}}
      scope: keyword.control.flow.return.lisp
    # Loop
    - match: \b(?i:for){{end_identifier}}
      scope: keyword.control.loop.for.lisp
    - match: \b(?i:while){{end_identifier}}
      scope: keyword.control.loop.while.lisp
    - match: \b(?i:do\*?|do-(?:all-|external)?symbols|dolist|doing|dotimes){{end_identifier}}
      scope: keyword.control.loop.do-while.lisp
    - match: \b(?i:loop){{end_identifier}}
      scope: keyword.control.loop.lisp
    - match: |-
        \b(?xi:
          with|when|typecase|to|thereis|return-from name|
          repeat|never|named|maplist|mapl|mapcon|mapcar|mapcan|
          mapc|into|initially|in|from|finally|etypecase|
          ctypecase|block|as|always
        ){{end_identifier}}
      scope: keyword.control.lisp
    - match: '\B={{end_identifier}}'
      scope: keyword.operator.assignment.lisp

  functions:
    - match: \b(?i:(defun|defmethod|deftype))\b\s+({{identifier}})\s*
      scope: meta.function.lisp
      captures:
        1: storage.type.function-type.lisp
        2: entity.name.function.lisp
      with_prototype:
        - include: parameter-modifiers-for-function
      push: expect-parameters
    - match: \b(?i:(defmacro))\b\s+({{identifier}})\s*
      scope: meta.function.lisp
      captures:
        1: storage.type.function-type.lisp
        2: entity.name.function.lisp
      with_prototype:
        - include: parameter-modifiers-for-macro
      push: expect-parameters
    - match: \b(?i:(defstruct))\b\s+({{identifier}})\s*
      scope: meta.function.lisp
      captures:
        1: storage.type.function-type.lisp
        2: entity.name.function.lisp
      push: expect-parameters
    - match: \b(lambda)(\s*){{end_identifier}}
      captures:
        1: >-
          meta.function.inline.lisp
          storage.type.function.inline.lisp
          keyword.declaration.function.inline.lisp
        2: meta.function.lisp
      with_prototype:
        - include: parameter-modifiers-for-lambda
      push: expect-parameters
    - match: \b(?i:string-char-p){{end_identifier}}
      scope: invalid.deprecated.lisp
    - match: '{{declarations}}'
      scope: keyword.declaration.lisp
    - match: |-
        \b(?xi:
          zerop|yes-or-no-p|y-or-n-p|write-to-string|write-string|write-char|
          write-byte|write|with-standard-io-syntax|
          with-simple-restart|with-package-iterator|
          with-hash-table-iterator|
          with-compilation-unit|wild-pathname-p|warn|vectorp|
          vector-push-extend|vector-push|vector-pop|vector|
          variable-information|values-list|values|user-homedir-pathname|
          use-value|use-package|upper-case-p|upgraded-complex-part-type|
          upgraded-array-element-type|update-instance-for-redefined-class|
          update-instance-for-different-class|unuse-package|untrace|until-if|
          until|unread-char|union|unintern|unexport|typep|type-of|
          type-error-expected-type|type-error-datum|
          two-way-stream-output-stream|two-way-stream-input-stream|truncate|
          truename|tree-equal|translate-pathname|translate-logical-pathname|
          trace|to-alter|time|third|terpri|terminate-producing|tenth|tanh|tan|
          tailp|synonym-stream-symbol|symbolp|symbol-value|symbol-plist|
          symbol-package|symbol-name|symbol-function|sxhash|svref|summing|sum|
          subtypep|substitute-if-not|substitute-if|substitute|subst-if-not|
          subst-if|subst|subsetp|subseries|subseq|sublis|stringp|string>=|
          string>|string=|string<=|string<|string/=|string-upcase|string-trim|
          string-right-trim|string-not-lessp|string-not-greaterp|
          string-not-equal|string-lessp|string-left-trim|string-greaterp|
          string-equal|string-downcase|string-capitalize|string|
          streamp|stream-external-format|stream-error-stream|
          stream-element-type|store-value|step|standard-char-p|stable-sort|
          sqrt|split-if|split|special-form-p|sort|some|software-version|
          software-type|slot-value|slot-unbound|slot-missing|slot-makunbound|
          slot-exists-p|slot-boundp|sleep|sixth|sinh|sin|simple-vector-p|
          simple-string-p|simple-condition-format-string|
          simple-condition-format-arguments|simple-bit-vector-p|signum|signal|
          short-site-name|shiftf|shared-initialize|shadowing-import|shadow|
          seventh|setq|setf|set-syntax-from-char|set-pprint-dispatch|
          set-macro-character|set-exclusive-or|set-dispatch-macro-character|
          set-difference|set-char-bit|set|series|second|search|schar|
          scan-symbols|scan-sublists|scan-range|scan-plist|scan-multiple|
          scan-lists-of-lists-fringe|scan-lists-of-lists|scan-hash|
          scan-fn-inclusive|scan-fn|scan-file|scan-alist|scan|scale-float|sbit|
          rplacd|rplaca|row-major-aref|round|rotatef|room|reverse|revappend|
          result-of|restart-name|restart-case|restart-bind|rest|require|
          replace|rename-package|rename-file|remprop|remove-method|
          remove-duplicates|remove|remhash|remf|reinitialize-instance|reduce|
          realpart|realp|readtablep|readtable-case|read-preserving-whitespace|
          read-line|read-from-string|read-delimited-list|read-char-no-hang|
          read-char|read-byte|read|rationalp|rationalize|rational|
          rassoc-if-not|rassoc-if|rassoc|random-state-p|random|quote|pushnew|
          push|psetq|psetf|provide|progn|prog2|prog1|producing|
          probe-file|print-unreadable-object|print-object|print|prin1|previous|
          pprint-tabular|pprint-tab|pprint-pop|pprint-newline|
          pprint-logical-block|pprint-linear|pprint-indent|pprint-fill|
          pprint-exit-if-list-exhausted|pprint-dispatch|positions|
          position-if-not|position-if|position|pop|plusp|phase|peek-char|
          pathnamep|pathname-version|pathname-type|pathname-name|
          pathname-match-p|pathname-host|pathname-directory|pathname-device|
          pathname|parse-namestring|parse-macro|parse-integer|pairlis|packagep|
          package-used-by-list|package-use-list|package-shadowing-symbols|
          package-nicknames|package-name|package-error-package|output-stream-p|
          open-stream-p|open|oddp|nunion|numerator|numberp|nthcdr|nth-value|
          nth|nsubstitute-if-not|nsubstitute-if|nsubstitute|nsubst-if-not|
          nsubst-if|nsubst|nsublis|nstring-upcase|nstring-downcase|
          nstring-capitalize|nset-exclusive-or|nset-difference|nreverse|
          nreconc|notevery|notany|no-next-method|no-applicable-method|ninth|
          nintersection|next-out|next-method-p|next-in|nconcing|nconc|nbutlast|
          namestring|name-char|multiple-value-setq|multiple-value-list|
          multiple-value-bind|muffle-warning|mismatch|minusp|minimizing|
          minimize|mingle|method-qualifiers|method-combination-error|
          merge-pathnames|merge|memberp|member-if-not|member-if|member|
          maximizing|maximize|mask-field|mask|mapping|maphash|map-into|map-fn|
          map|makunbound|make-two-way-stream|make-synonym-stream|make-symbol|
          make-string-output-stream|make-string-input-stream|make-string|
          make-sequence|make-random-state|make-pathname|make-package|
          make-load-form-saving-slots|make-load-form|make-list|
          make-instances-obsolete|make-instance|make-hash-table|
          make-echo-stream|make-dispatch-macro-character|make-condition|
          make-concatenated-stream|make-char|make-broadcast-stream|make-array|
          macroexpand-1|macroexpand|macro-function|machine-version|
          machine-type|machine-instance|lower-case-p|loop-finish|
          long-site-name|logtest|logorc2|logorc1|lognot|lognand|
          logical-pathname-translations|logical-pathname|logcount|logbitp|
          logandc2|logandc1|log|locally|load-logical-pathname-translations|
          load|listp|listen|list-length|list-all-packages|list\*|list|
          lisp-implementation-version|lisp-implementation-type|length|ldiff|
          ldb-test|ldb|lcm|latch|last|keywordp|iterate|isqrt|invoke-restart|
          invoke-debugger|invalid-method-error|intersection|intern|
          interactive-stream-p|integerp|integer-length|integer-decode-float|
          int-char|inspect|input-stream-p|initialize-instance|in-package|
          import|imagpart|ignore-errors|identity|host-namestring|
          hash-table-test|hash-table-size|hash-table-rehash-threshold|
          hash-table-rehash-size|hash-table-p|hash-table-count|handler-case|
          handler-bind|graphic-char-p|gethash|getf|get-universal-time|
          get-setf-method-multiple-value|get-setf-method|get-properties|
          get-output-stream-string|get-internal-run-time|
          get-internal-real-time|get-decoded-time|get|gentemp|gensym|
          generic-function|generator|gcd|gathering|gatherer|functionp|
          function-lambda-expression|function-keywords|function-information|
          funcall|fourth|formatter|format|floor|floatp|float-sign|float-radix|
          float-precision|float-digits|float|first|finish-output|find-symbol|
          find-restart|find-package|find-method|find-if-not|find-if|find-class|
          find-all-symbols|find|fill-pointer|fill|file-write-date|
          file-string-length|file-position|file-namestring|file-length|
          file-error-pathname|file-author|fifth|ffloor|fdefinition|fboundp|f|
          expt|export|expand|exp|every|evenp|evalhook|eval|error|
          ensure-generic-function|enough-namestring|endp|encode-universal-time|
          enclose|encapsulated|elt|eighth|ed|echo-stream-output-stream|
          echo-stream-input-stream|ecase|dribble|dpb|documentation|do-symbols|
          do-external-symbols|do-all-symbols|disassemble|directory-namestring|
          directory|digit-char-p|digit-char|destructuring-bind|describe-object|
          describe|deposit-field|denominator|delete-package|delete-if-not|
          delete-if|delete-file|delete-duplicates|delete|
          decode-universal-time|
          decode-float|declaration-information|declaim|counting|count-if-not|
          count-if|count|cotruncate|cosh|cos|copy-tree|copy-symbol|copy-seq|
          copy-readtable|copy-pprint-dispatch|copy-list|copy-alist|continue|
          constantp|consp|cons|conjugate|concatenated-stream-streams|
          concatenate|compute-restarts|compute-applicable-methods|complexp|
          complex|complement|compiler-macroexpand-1|compiler-macroexpand|
          compiler-macro-function|compiler-let|compiled-function-p|
          compile-file-pathname|compile-file|compile|commonp|collecting-fn|
          collecting|collect-sum|collect-plist|collect-or|collect-nth|
          collect-nconc|collect-min|collect-max|collect-length|collect-last|
          collect-hash|collect-fn|collect-first|collect-file|collect-append|
          collect-and|collect-alist|collect|coerce|code-char|clrhash|close|
          clear-input|class-of|class-name|cis|chunk|choose-if|choose|
          check-type|characterp|character|char>=|char>|char=|char<=|char<|
          char/=|char-upcase|char-not-lessp|char-not-greaterp|char-not-equal|
          char-name|char-lessp|char-int|char-greaterp|char-font|char-equal|
          char-downcase|char-code|char-bits|char-bit|char|change-class|cerror|
          cell-error-name|ceiling|cdr|cddr|cdddr|cddddr|cdddar|cddar|cddadr|
          cddaar|cdar|cdadr|cdaddr|cdadar|cdaar|cdaadr|cdaaar|ccase|catenate|
          car|call-next-method|call-method|cadr|caddr|cadddr|caddar|cadar|
          cadadr|cadaar|caar|caadr|caaddr|caadar|caaar|caaadr|caaaar|byte-size|
          byte-position|byte|butlast|broadcast-stream-streams|break|boundp|
          both-case-p|boole|bit-xor|bit-vector-p|bit-orc2|bit-orc1|bit-not|
          bit-nor|bit-nand|bit-ior|bit-eqv|bit-andc2|bit-andc1|bit-and|bit|
          augment-environment|atom|atanh|atan|assoc-if-not|assoc-if|assoc|
          assert|asinh|asin|ash|arrayp|array-total-size|array-row-major-index|
          array-rank|array-in-bounds-p|array-has-fill-pointer-p|
          array-element-type|array-dimensions|array-dimension|
          arithmetic-error-operation|arithmetic-error-operands|aref|
          apropos-list|apropos|applyhook|apply|appending|append|alter|
          alphanumericp|alpha-char-p|adjustable-array-p|adjust-array|adjoin|
          add-method|acosh|acos|acons|abs|abort
        ){{end_identifier}}
      scope: support.function.lisp

  types:
    - match: \b(?i:common|string-char){{end_identifier}}
      scope: invalid.deprecated.lisp
    - match: |-
        \b(?xi:
          array|atom|bignum|bit|bit-vector|character|
          compiled-function|complex|cons|double-float|fixnum|float|function|
          hash-table|integer|keyword|list|long-float|nil|null|number|package|
          pathname|random-state|ratio|rational|readtable|sequence|short-float|
          signed-byte|simple-array|simple-bit-vector|simple-string|simple-vector|
          single-float|standard-char|stream|string|symbol|t|
          unsigned-byte|vector
        ){{end_identifier}}
      scope: storage.type.lisp
      # scope: support.type.lisp

  parameter-modifiers-common:
    - match: (&)(?i:optional|rest|key|aux){{end_identifier}}
      scope: variable.annotation.lisp
      captures:
        1: punctuation.definition.annotation.lisp

  parameter-modifiers-for-function:
    - include: parameter-modifiers-common
    - include: parameter-modifier-allow-other-keys

  parameter-modifiers-for-lambda:
    - include: parameter-modifiers-common
    - include: parameter-modifier-required

  parameter-modifiers-for-macro:
    - include: parameter-modifiers-common
    - include: parameter-modifier-allow-other-keys
    - match: (&)(?i:body|whole|environment){{end_identifier}}
      scope: variable.annotation.lisp
      captures:
        1: punctuation.definition.annotation.lisp

  parameter-modifier-required:
    - match: (&)(?i:required){{end_identifier}}
      scope: variable.annotation.lisp
      captures:
        1: punctuation.definition.annotation.lisp

  parameter-modifier-allow-other-keys:
    - match: (&)(?i:allow-other-keys){{end_identifier}}
      scope: variable.annotation.lisp
      captures:
        1: punctuation.definition.annotation.lisp

  expect-parameters:
    - match: \(
      scope: punctuation.section.parameters.begin.lisp
      push:
        - meta_scope: meta.function.parameters.lisp
        - match: \)
          scope: punctuation.section.parameters.end.lisp
          pop: true
        - match: '{{identifier}}'
          scope: variable.parameter.lisp
        - match: \(
          scope: punctuation.definition.group.begin.lisp
          push:
            - match: \)
              scope: punctuation.definition.group.end.lisp
              pop: true
            - include: strings
            - include: constants
            - include: numbers
            - match: '{{identifier}}'
              scope: variable.parameter.lisp
    - match: ''
      pop: true

  operators:
    - match: (?:\B(?:/=|>=|<=|=|>|<)|\b(?i:max|min|eq|neq|eql|equalp|equal)){{end_identifier}}
      scope: keyword.operator.comparison.lisp
    - match: (?:\B(?:\+|-|\*|/)|\b(?i:mod|rem|incf|decf)){{end_identifier}}
      scope: keyword.operator.arithmetic.lisp
    - match: \b(?i:and|or|not)(?=[\s()]|$)
      scope: keyword.operator.logical.lisp
    - match: \b(?i:logand|logior|logxor|lognor|logeqv){{end_identifier}}
      scope: keyword.operator.bitwise.lisp

  parens:
    # ()
    - match: (?:(')|(`))?(\(\))
      captures:
        1: keyword.other.no-evaluation.lisp
        2: punctuation.definition.variable.lisp
        3: constant.language.lisp
    # '(...)
    - match: (')(\()
      captures:
        1: keyword.other.no-evaluation.lisp
        2: punctuation.definition.group.begin.lisp
      push:
        - meta_scope: meta.group.lisp
        - match: \)
          scope: punctuation.definition.group.end.lisp
          pop: true
        - include: expressions
        - include: parens
        - include: functions
        - include: identifiers
    # (...)
    - match: (`)?(\()\s*
      captures:
        1: punctuation.definition.variable.lisp
        2: punctuation.definition.group.begin.lisp
      push:
        - expect-closing-paren
        - expect-function
    - match: \)
      scope: invalid.illegal.stray-bracket-end.lisp

  expect-function:
    - match: (?=[\s)"',])
      pop: true
    - match: \B\.{{end_identifier}}
      scope: invalid.illegal.lisp
    - include: operators
    - include: expressions
    - include: functions
    - include: parens
    - match: '{{identifier}}'
      scope: >-
        meta.function-call.lisp
        variable.function.lisp

  expect-closing-paren:
    - meta_scope: meta.group.lisp
    - match: \)
      scope: punctuation.definition.group.end.lisp
      pop: true
    - include: expressions
    - include: parens
    - include: function-keywords
    - include: identifiers
    # Could add some "expect" stuff here to allow only one
    #   more element in the parens

  constants:
    - match: |-
        \b(?xi:
          null|nil|t|pi|
          (?:single|short|long|double)-float-(?:negative-)?epsilon|
          (?:most|least)-(?:positive|negative)-(?:single|short|long|double)-float|
          least-(?:positive|negative)-normalized-(?:single|short|long|double)-float|
          most-(?:positive|negative)-fixnum|
          multiple-values-limit|
          lambda-parameters-limit|
          lambda-list-keywords|
          internal-time-units-per-second|
          char-(?:super|hyper|meta|control)-bit|
          char-(?:font|code|bits)-limit|
          call-arguments-limit|
          array-(?:rank|dimension|total-size)-limit
        ){{end_identifier}}
      scope: constant.language.lisp

  dispatching-macros:
    # https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node191.html
    - include: dispatching-macro-characters
    - include: dispatching-macro-throw-exception
    - include: dispatching-macro-numbers
    # Function reference
    - match: (#')({{identifier}})
      captures:
        1: punctuation.definition.function.lisp
        2: variable.function.lisp
    - match: (#')(\()\s*(lambda)\s*{{end_identifier}}
      captures:
        1: punctuation.definition.function.lisp
        2: punctuation.definition.group.begin.lisp
        3: >-
          meta.function.inline.lisp
          storage.type.function.inline.lisp
          keyword.declaration.function.inline.lisp
      with_prototype:
        - include: parameter-modifiers-for-lambda
      push:
        - expect-closing-paren
        - expect-parameters
    # Bit vector
    - match: (#\d*\*)[01]*{{end_identifier}}
      scope: variable.other.lisp
      captures:
        1: punctuation.definition.variable.lisp
    # Inline eval
    - match: (#(?:(,)|(\.)))({{identifier}})
      captures:
        1: punctuation.definition.variable.lisp
        2: variable.function.lisp # load-time evaluation
        3: variable.function.lisp # read-time evaluation
        4: variable.other.lisp
    # Feature-flags
    - match: (#([+-]))({{identifier}})
      scope: variable.other.lisp
      captures:
        1: keyword.control.conditional.if.lisp
        2: keyword.operator.logical.lisp
        3: variable.other.lisp
    # Local assignment
    - match: ((#)\d+)(=)
      captures:
        1: variable.other.local.lisp
        2: punctuation.definition.variable.lisp
        3: keyword.operator.assignment.lisp
    - match: (#)(\d+)(#)
      scope: variable.other.lisp
      captures:
        1: punctuation.definition.variable.begin.lisp
        2: variable.other.local.lisp
        3: punctuation.definition.variable.end.lisp
    # Vector, list, array
    - match: (#\d*)(\()
      captures:
        1: keyword.declaration.vector.lisp
        2: punctuation.definition.group.begin.lisp
      push: expect-closing-paren
    - match: (#\d*[aA])(\()
      captures:
        1: keyword.declaration.array.lisp
        2: punctuation.definition.group.begin.lisp
      push: expect-closing-paren
    - match: (#\d*[aA])({{identifier}})
      captures:
        1: keyword.declaration.array.lisp
        2: variable.other.lisp
    # Still need #:, #S, #P

  dispatching-macro-characters:
    - match: (#\\)(?i:Space|NewLine){{end_identifier}}
      scope: constant.character.standard.lisp
      captures:
        1: punctuation.definition.constant.lisp
    - match: (#\\)(?i:Backspace|Tab|Linefeed|Page|Return|RubOut){{end_identifier}}
      scope: constant.character.semi-standard.lisp
      captures:
        1: punctuation.definition.constant.lisp
    - match: (#\\){{standard_char}}{{end_identifier}}
      scope: constant.character.standard.lisp
      captures:
        1: punctuation.definition.constant.lisp
    - match: (#\\){{identifier_char}}+{{end_identifier}}
      scope: constant.character.non-standard.lisp
      captures:
        1: punctuation.definition.constant.lisp

  dispatching-macro-throw-exception:
    - match: '#[ \t\n\r)<]'
      scope: keyword.control.exception.throw.lisp

  dispatching-macro-numbers:
    - match: (#[bB])[01]+(?:(/)[01]+)?
      scope: constant.numeric.integer.binary.lisp
      captures:
        1: punctuation.definition.constant.lisp
        2: punctuation.separator.sequence.lisp
    - match: (#[oO])[0-7]+(?:(/)[0-7]+)?
      scope: constant.numeric.integer.octal.lisp
      captures:
        1: punctuation.definition.constant.lisp
        2: punctuation.separator.sequence.lisp
    - match: (#[xX])\h+(?:(/)\h+)?
      scope: constant.numeric.integer.hexadecimal.lisp
      captures:
        1: punctuation.definition.constant.lisp
        2: punctuation.separator.sequence.lisp
    - match: (?i:(#\d+r)[\da-z]+(?:(/)[\da-z]+)?)
      scope: constant.numeric.integer.other.lisp
      captures:
        1: punctuation.definition.constant.lisp
        2: punctuation.separator.sequence.lisp
    - match: (#[cC])(\()
      captures:
        1: punctuation.definition.constant.lisp
        2: punctuation.definition.group.begin.lisp
      push: expect-closing-paren

  function-keywords:
    - match: (:){{identifier}}
      scope: variable.parameter.lisp
      captures:
        1: punctuation.definition.keyword.lisp

  identifiers:
    - match: (?:(')|(`,?|,@?))?(\|)
      captures:
        1: keyword.other.no-evaluation.lisp
        2: punctuation.definition.variable.lisp
        3: >-
          variable.other.lisp
          punctuation.definition.variable.begin.lisp
      push:
        - meta_content_scope: variable.other.lisp
        - match: \n
          scope: invalid.illegal.trailing-newline.lisp
          pop: true
        - match: \|
          scope: >-
            variable.other.lisp
            punctuation.definition.variable.end.lisp
          pop: true
    - match: (?:(')|(`,?|,@?))?({{identifier}})
      captures:
        1: keyword.other.no-evaluation.lisp
        2: punctuation.definition.variable.lisp
        3: variable.other.lisp

  numbers:
    - match: |-
        (')?-?(?x:
          (?:
            (?:0[xX]\h+)|
            (?:\d+(/)\d+)|
            (?:
              (\d+\.?\d*)|
              (?:\.\d+)
            )
              ([eE][+-]?\d+)?
          )
          (?i:l|ul|u|f|ll|ull)?
        ){{end_identifier}}
      scope: constant.numeric.lisp
      captures:
        1: keyword.other.no-evaluation.lisp
        2: punctuation.separator.sequence.lisp

  strings:
    - match: '"'
      scope: punctuation.definition.string.begin.lisp
      push:
        - meta_scope: string.quoted.double.lisp
        - match: '"'
          scope: punctuation.definition.string.end.lisp
          pop: true
        - match: \\.
          scope: constant.character.escape.lisp
        - include: string-format-mini-language

  string-format-mini-language:
    # https://www.hexstreamsoft.com/articles/common-lisp-format-reference/clhs-summary/#subsections-summary-table
    - match: (~)(\d*)[%&|~]
      scope: constant.character.escape.lisp
      captures:
        1: punctuation.definition.placeholder.lisp
        # 2: constant.numeric.integer.decimal.lisp
    - match: (~):?@?[CR]
      scope: constant.other.placeholder.lisp
      captures:
        1: punctuation.definition.placeholder.lisp
    # ~R
    - match: |-
        (?x:
          (~)
          (?:(\d*)             # Radix
            (?:(,)\d*          # mincol
              (?:(,)(?:'.)?    # padchar
                (?:(,)(?:'.)?  # comma-char
                  (?:(,)\d*)?  # comma-interval
          )?)?)?)
        ):?@?[rR]
      scope: constant.other.placeholder.lisp
      captures:
        1: punctuation.definition.placeholder.lisp
        2: punctuation.definition.numeric.base.lisp
        3: punctuation.separator.sequence.lisp
        4: punctuation.separator.sequence.lisp
        5: punctuation.separator.sequence.lisp
        6: punctuation.separator.sequence.lisp
    # ~b, ~o, ~d, ~x
    - match: |-
        (?x:
          (~)
          (?:\d*             # mincol
            (?:(,)(?:'.)?    # padchar
              (?:(,)(?:'.)?  # comma-char
                (?:(,)\d*)?  # comma-interval
          )?)?)?
        ):?@?[bBoOdDxX]
      scope: constant.other.placeholder.lisp
      captures:
        1: punctuation.definition.placeholder.lisp
        2: punctuation.separator.sequence.lisp
        3: punctuation.separator.sequence.lisp
        4: punctuation.separator.sequence.lisp
    # ~f
    - match: |-
        (?x:
          (~)
          (?:\d*                 # width
            (?:(,)\d*            # decimals
              (?:(,)\d*          # scale
                (?:(,)(?:'.)?    # overflowchar
                  (?:(,)(?:'.)?  # padchar
          )?)?)?)?)?
        )@?[fF]
      scope: constant.other.placeholder.lisp
      captures:
        1: punctuation.definition.placeholder.lisp
        2: punctuation.separator.sequence.lisp
        3: punctuation.separator.sequence.lisp
        4: punctuation.separator.sequence.lisp
        5: punctuation.separator.sequence.lisp
    # ~e, ~g
    - match: |-
        (?x:
          (~)
          (?:\d*                     # width
            (?:(,)\d*                # decimals
              (?:(,)\d*              # exponent-width
                (?:(,)\d*            # scale
                  (?:(,)(?:'.)?      # overflowchar
                    (?:(,)(?:'.)?    # padchar
                      (?:(,)(?:'.)?  # exponentchar
          )?)?)?)?)?)?)?
        )@?[eEgG]
      scope: constant.other.placeholder.lisp
      captures:
        1: punctuation.definition.placeholder.lisp
        2: punctuation.separator.sequence.lisp
        3: punctuation.separator.sequence.lisp
        4: punctuation.separator.sequence.lisp
        5: punctuation.separator.sequence.lisp
        6: punctuation.separator.sequence.lisp
        7: punctuation.separator.sequence.lisp
    # ~$
    - match: |-
        (?x:
          (~)
          (?:\d*               # decimals
            (?:(,)\d*          # min-units
              (?:(,)\d*        # min-width
                (?:(,)(?:'.)?  # padchar
          )?)?)?)?
        ):?@?\$
      scope: constant.other.placeholder.lisp
      captures:
        1: punctuation.definition.placeholder.lisp
        2: punctuation.separator.sequence.lisp
        3: punctuation.separator.sequence.lisp
        4: punctuation.separator.sequence.lisp
    # ~a, ~s
    - match: |-
        (?x:
          (~)
          (?:\d*               # min-col
            (?:(,)\d*          # col-inc
              (?:(,)\d*        # min-pad
                (?:(,)(?:'.)?  # padchar
          )?)?)?)?
        ):?@?[aAsS]
      scope: constant.other.placeholder.lisp
      captures:
        1: punctuation.definition.placeholder.lisp
        2: punctuation.separator.sequence.lisp
        3: punctuation.separator.sequence.lisp
        4: punctuation.separator.sequence.lisp

  block-comment:
    - match: '#\|'
      scope: punctuation.definition.comment.begin.lisp
      push:
        - meta_scope: comment.block.lisp
        - include: block-comment
        - match: '\|#'
          scope: punctuation.definition.comment.end.lisp
          pop: true

  comments:
    - include: block-comment
    - match: \|#
      scope: invalid.illegal.stray-comment-end.lisp
    - match: ;+
      scope: punctuation.definition.comment.lisp
      push:
        - meta_scope: comment.line.semicolon.lisp
        - match: $\n?
          pop: true
